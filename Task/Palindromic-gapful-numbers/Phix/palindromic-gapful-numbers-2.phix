--
-- demo\rosetta\Palindromic_gapful_numbers.exw
-- ===========================================
--
--  Astonishingly this is all done with standard precision numbers, <2^53.
--  I will credit Self_numbers#AppleScript and comment by Nigel Galloway
--  on the talk page for ideas that inspired me.
--
--  A palindrome such as 9459549 can be constructed/broken down into
--                       9000009
--                        400040
--                         50500
--                          9000
--
-- Further, 9459549 rem 99 is the same as
--  (the sum of rem 99 on all of those pieces) rem 99
--
-- Finding eg 400040 rem 99 can also be simplified, it is of course the
--   same as (400000 rem 99 + 40 rem 99) rem 99, and further 40 rem 99
--   is the same as (4 rem 99[already known])*10 rem 99 [smaller nos].
--
-- Also, when filling a "hole", such as the final 9, we find
--             v
--          9450549 rem 99 = 9
--          9451549 rem 99 = 19,
--          9452549 rem 99 = 29,
--          9453549 rem 99 = 39,
--          9454549 rem 99 = 49,
--          9455549 rem 99 = 59,
--          9456549 rem 99 = 69,
--          9457549 rem 99 = 79,
--          9458549 rem 99 = 89, and
--          9459549 rem 99 = 0,
--             ^
--  in this case only the '9' fits.
--
-- But actually we can predict what will fit from the partial sum of
--  prior pieces rem 99, ie 9000009..50500, and the same can be said
--  when filling the 505-sized hole - what will "fit" depends not on
--  what the "outer" actually are, but what their sum rem 99 is, and
--  likewise for larger and larger holes.
--  If we later find ourselves looking at the same size hole, with
--  the same outer rem and the same rem 99 outmost requirement, we
--  would know instantly how many things are going to fit.
--  True, keeping full lists as the holes got bigger would probably
--  consume memory almost as fast as an SR-71, but a single count,
--  albeit one keyed on 4 conditions, we can cope. It turns out that
--  even by the 10^15th scan, we only hit 17,579 variations anyway.
--  As we stumble across larger and larger holes, what we learn can
--  be used to skip more and more similar, such that finding the
--  ten millionth item is almost as fast as the first millionth, as
--  opposed to the times 10 that you'd normally expect.
--
-- Note that if I stumble across a hole that will fit more than I'm
--  prepared to fully skip, I start going through things one-by-one,
--  but that's ok because many smaller but still quite big holes
--  will probably be skipped.
--
with javascript_semantics

sequence cache = columnize(repeat(columnize({tagset(9)}),9))
--   ie {{{1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}},
--       {{2}, {2}, {2}, {2}, {2}, {2}, {2}, {2}, {2}},
--       {{3}, {3}, {3}, {3}, {3}, {3}, {3}, {3}, {3}},
--       {{4}, {4}, {4}, {4}, {4}, {4}, {4}, {4}, {4}},
--       {{5}, {5}, {5}, {5}, {5}, {5}, {5}, {5}, {5}},
--       {{6}, {6}, {6}, {6}, {6}, {6}, {6}, {6}, {6}},
--       {{7}, {7}, {7}, {7}, {7}, {7}, {7}, {7}, {7}},
--       {{8}, {8}, {8}, {8}, {8}, {8}, {8}, {8}, {8}},
--       {{9}, {9}, {9}, {9}, {9}, {9}, {9}, {9}, {9}}}
-- aka 1 rem 11 .. 1 rem 99 are all 1,
--  .. 9 rem 11 .. 9 rem 99 are all 9.
-- each gets extended with 10 rem 11 .. 10 rem 99,
--                        100 rem 11 .. 100 rem 99,
--                    ...            .. 900 rem 99, etc.
-- (not really worth trying to take advantage of any cycles
--  that might appear in such a relatively small table, as
--  it will be at most (on 64-bit) 9 * 9 * 42.)
--
function rmdrn(integer digit, gap, pow, n)
--
-- digit is the outer 0..9 (obvs 0 always yields 0),
-- gap is zeroes between (-1,0,1,2,.. for eg 1,11,101,1001),
-- pow is trailing zeros (0,1,2,.. for eg 101,1010,10100),
-- n is 1..9 for 11..99
-- eg rmdrn(4,3,2,1) yields remainder(4000400,11), but
--       that === remainder(remainder(4000000,11)+
--                          remainder(    400,11),11), and
--  if k = remainder(4*10^(m-1),11) [already known] then
--         remainder(4*10^m,11) === remainder(k*10,11), so
--  we only need to keep a small table for each [digit][n].
--  Thus we avoid maths on 10^42-ish numbers/needing gmp.
--
    if digit=0 then return 0 end if
    integer nn = n*11, g
    sequence cdn = cache[digit][n]
    while length(cdn)<gap+pow+2 do
        cache[digit][n] = 0 -- (kill refcount)
        cdn &= remainder(cdn[$]*10,nn)
        cache[digit][n] = cdn
    end while
    g = iff(gap=-1 ? 0 : cdn[gap+pow+2])
    return remainder(g + cdn[pow+1],nn)
end function

integer skipd = new_dict()

function palindromicgapfuls(sequence pals, string lhs, atom palcount, to_skip, count, integer l, r, p, dd)
--
-- pals: results (passing it up grants it automatic pass-by-reference status, which may help speedwise)
-- lhs: eg "945" of a potential 9459549 result
-- palcount, to_skip, count: self explanatory (aka got/ignore/target)
-- l: length of inner to be filled in
-- r: remainder of outer, eg remainder(9400049,11), built from rmdrn()
-- p: left shift (should in fact always equal length(lhs), I think)
-- dd: outermost 1..9 (despite the name, it's a single digit)
--
    sequence key = {l,r,p,dd}
    integer node = getd_index(key,skipd)
    atom skip = iff(node==null?count:getd_by_index(node,skipd)), skipn
    if node!=null and (palcount+skip)<to_skip then
        palcount += skip
    else
        skip = 0
        for d=0 to 9 do
            integer r2 = remainder(r+rmdrn(d,l-2,p,dd),dd*11)
            if l<=2 then
                if r2=0 then
                    palcount += 1
                    if palcount<=to_skip then
                        skip += 1
                    else
                        pals = append(deep_copy(pals),lhs&repeat(d+'0',l)&reverse(lhs))
                    end if
                end if
            else
                {pals,palcount,skipn} = palindromicgapfuls(pals,lhs&(d+'0'),palcount,to_skip,count,l-2,r2,p+1,dd)
                skip += skipn
            end if
            if palcount==count then exit end if
        end for
        if palcount<to_skip then setd(key,skip,skipd) end if
    end if
    return {pals,palcount,skip}
end function

function collect(integer digit, atom count, keep)
    atom to_skip = count - keep,
            palcount =  0, l = 3
    sequence pals = {}
    string lhs = ""&(digit+'0') -- ie "1" or "2" .. or "9"
    while palcount < count do
        integer r = rmdrn(digit,l-2,0,digit)
        {pals,palcount} = palindromicgapfuls(pals,lhs,palcount,to_skip,count,l-2,r,1,digit)
        l += 1
    end while
    return pals
end function

constant tests = {{20,20,1,9},{100,15,1,9},{1000,10,1,9},{10_000,5,1,9},
                  {100_000,1,1,9},{1_000_000,1,1,9},{10_000_000,1,1,9},
                  {100_000_000,1,9,9},{1000_000_000,1,9,9},{10_000_000_000,1,9,9},
                  {100_000_000_000,1,9,9},{1000_000_000_000,1,9,9},
                  {10_000_000_000_000,1,9,9},{100_000_000_000_000,1,9,9},
                  {1_000_000_000_000_000,1,9,9},
--                {1_000_000_000_000_000,1,2,4}, -- (matches AppleScript)
                  {10_000_000_000_000_000_000,1,9,9}} -- 64 bit only
                 -- (any further and you'd need mpfr just to hold counts)

atom t0 = time(), count, keep, start, finish
for i=1 to length(tests)-(machine_bits()!=64) do
    {count, keep, start, finish} = tests[i]
    string r = iff(count==keep?sprintf("First %d",{count}):
                    iff(keep>1?sprintf("Last %d of first %,d",{keep,count})
                              :sprintf("%,dth",{count}))),
           s = iff(keep=1?"":"s")
    printf(1,"%s palindromic gapful number%s ending with:\n", {r,s})
    sequence tags = tagset(finish,start),
             res = apply(true,collect,{tags,count,keep})
    string fmt = sprintf("%%%ds",max(apply(join(res,{}),length)))
    for j=1 to length(res) do
        printf(1,"%d: %s\n",{tags[j],join(apply(true,sprintf,{{fmt},res[j]})," ")})
    end for
    puts(1,"\n")
end for
printf(1,"Completed in %s\n",elapsed(time()-t0))
