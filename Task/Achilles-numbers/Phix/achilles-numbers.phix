with javascript_semantics
requires("1.0.2") -- [join_by(fmt)]
atom t0 = time()
constant maxDigits = iff(platform()=JS?10:12)
integer pps = new_dict()

procedure getPerfectPowers(integer maxExp)
    atom hi = power(10, maxExp), t1 = time()+1
    integer imax = floor(sqrt(hi))
    for i=2 to imax do
        atom p = i
        while true do
            p *= i
            if p>=hi then exit end if
            setd(p,true,pps)
        end while
        if time()>t1 then
            progress("getting perfect powers, %d/%d\r",{i,imax})
            t1 = time()+1
        end if
    end for
    progress("")
end procedure

function get_achilles(integer minExp, maxExp)
    atom lo10 = power(10,minExp),
         hi10 = power(10,maxExp)
    integer bmax = floor(power(hi10,1/3)),
            amax = floor(sqrt(hi10))
    sequence achilles = {}
    for b=2 to bmax do
        atom b3 = b * b * b
        for a=2 to amax do
            atom p = b3 * a * a
            if p>=hi10 then exit end if
            if p>=lo10 then
                integer node = getd_index(p,pps)
                if node=NULL then
                    achilles &= p
                end if
            end if
        end for
    end for
    achilles = unique(achilles)
    return achilles
end function

getPerfectPowers(maxDigits)

sequence achilles = get_achilles(1,5),
         a = join_by(achilles[1..50],1,10," ",fmt:="%4d")
printf(1,"First 50 Achilles numbers:\n%s\n",{a})

function strong_achilles(integer n)
    integer totient = sum(sq_eq(apply(true,gcd,{tagset(n),n}),1))
    return find(totient,achilles)
end function

progress("filtering strong achilles...")
sequence sa = filter(achilles,strong_achilles)[1..30],
         ssa = join_by(sa,1,10," ",fmt:="%5d")
progress("")
printf(1,"First 30 strong Achilles numbers:\n%s\n",{ssa})
for d=2 to maxDigits do
    printf(1,"Achilles numbers with %d digits:%d\n",{d,length(get_achilles(d-1,d))})
end for
?elapsed(time()-t0)
