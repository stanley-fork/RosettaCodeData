with javascript_semantics
requires("1.0.2") -- (for in)
atom t0 = time()

function get_primes_by_digits(integer limit)
    sequence primes = get_primes_le(power(10,limit)),
             primes_by_digits = {}
    integer p = 10
    while length(primes) do
        integer pi = abs(binary_search(p,primes))-1
        primes_by_digits &= {primes[1..pi]}
        primes = primes[pi+1..$]
        p*= 10
    end while
    return primes_by_digits
end function
sequence primes_by_digits = get_primes_by_digits(8)

procedure first100()
    sequence brilliant_numbers = {}
    for primes in primes_by_digits do
        for i=1 to length(primes) do
--see talk page
--          for j=i to length(primes) do
            for j=1 to i do
                brilliant_numbers &= primes[i]*primes[j]
            end for
        end for
        if length(brilliant_numbers)>=100 then exit end if
    end for
    brilliant_numbers = sort(brilliant_numbers)[1..100]
    sequence j100 = join_by(brilliant_numbers,1,10," ","\n","%,5d")
    printf(1,"First 100 brilliant numbers:\n%s\n\n",{j100})
end procedure
first100()

atom pwr = 10, count = 0
for p=1 to 2*length(primes_by_digits)-1 do
    sequence primes = primes_by_digits[floor(p/2)+1]
    atom pos = count+1,
         min_product = 0
    for i=1 to length(primes) do
        integer p1 = primes[i],
                j = abs(binary_search(floor((pwr+p1-1)/p1),primes,i))
        if j<=length(primes) then -- (always is, I think)
            integer p2 = primes[j]
            atom prod = p1*p2
            if min_product=0 or prod<min_product then
                min_product = prod
            end if
            pos += j-i
            if p1>=p2 then exit end if
        end if
    end for
    printf(1,"First brilliant number >= 10^%d is %,d at position %,d\n", {p, min_product, pos})
    pwr *= 10;
    if odd(p) then
        integer size = length(primes)
        count += size * (size + 1) / 2;
    end if
end for
?elapsed(time()-t0)
{} = wait_key()
