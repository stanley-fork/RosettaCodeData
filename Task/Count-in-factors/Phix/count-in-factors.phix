with javascript_semantics
procedure factorise(integer n)
    sequence res = prime_factors(n,true,-1)
    printf(1,"%2d: %s\n",{n,join(res," x ",fmt:="%d")})
end procedure

papply(tagset(10)&{2144,1_000_000_000},factorise)

-- And this is how you deal with larger numbers - you'd have to cap maxprime
-- for anything larger, and in fact I had to do just that for this to work on
-- 32-bit (295593 found by binary chop), and of course some numbers will get
-- incredibly slow, or you could try using mpz_pollard_rho() instead.
puts(1,"\n")
include mpfr.e
for i=0 to 35 by 5 do
    string s = "1"&repeat('0',i)
    if even(i) then s[$] = '1' end if
    integer maxprime = iff(machine_bits()=32?295593:
                           floor(sqrt(power(10,i))))
    sequence res = mpz_prime_factors(s,maxprime)
    printf(1,"%s: %s\n",{s,mpz_factorstring(res)})
end for
