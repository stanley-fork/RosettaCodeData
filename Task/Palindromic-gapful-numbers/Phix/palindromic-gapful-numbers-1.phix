with javascript_semantics
function reverse_n(atom s)
    atom e = 0
    while s>0 do
        e = e*10 + remainder(s,10)
        s = floor(s/10)
    end while
    return e
end function

constant mx = 1000,
         data = {{1, 20, repeat("%6d",3)&
                         repeat("%7d",13)&
                         repeat("%8d",4)},
                 {86, 100, repeat("%9d",15)},
                 {991, 1000, repeat("%11d",10)}}

include builtins\ordinal.e

function digit(sequence results, integer d)
    integer count = 0, pow = 1, fl = d*11
    for nd=3 to 15 do -- (number of digits, usually quits early)
        -- (obvs. 64-bit phix is fine with 19 digits, but 32-bit ain't)
        bool odd = (remainder(nd,2)==1)
        for s=d*pow to (d+1)*pow-1 do   -- (eg 300 to 399)
            integer e = reverse_n(s)
            for m=0 to iff(odd?9:0) do  -- (1 or 10 iterations)
                atom p = e + iff(odd ? s*pow*100+m*pow*10
                                     : s*pow*10)
                if remainder(p,fl)==0 then  -- gapful!
                    count += 1
                    results[count][d] = p
                    if count==mx then return results end if
                end if
            end for
        end for
        if odd then pow *= 10 end if
    end for
    if count<mx then ?9/0 end if -- oh dear...
    return results
end function

procedure main()
    sequence results = repeat(repeat({},9),mx)
    for d=1 to 9 do -- (the start/end digit)
        results = digit(results,d)
    end for

    for i=1 to length(data) do
        {integer s, integer e, sequence fmts} = data[i]
        printf(1,"%,d%s to %,d%s palindromic gapful numbers (> 100) ending with:\n", {s,ord(s),e,ord(e)})
        for d=1 to 9 do
            printf(1,"%d:",d)
            for j=s to e do
                printf(1,fmts[j-s+1],results[j][d])
            end for
            printf(1,"\n")
        end for
        printf(1,"\n")
    end for
end procedure
main()
